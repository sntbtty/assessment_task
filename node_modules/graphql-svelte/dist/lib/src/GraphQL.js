"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQL = void 0;
var mitt_1 = __importDefault(require("mitt"));
var graphqlFetchOptions_1 = require("./graphqlFetchOptions");
var hashObject_1 = require("./hashObject");
var _a = mitt_1.default(), on = _a.on, off = _a.off, emit = _a.emit;
/**
 * A lightweight GraphQL client that caches queries and mutations.
 * @kind class
 * @name GraphQL
 * @param {object} [options={}] Options.
 * @param {GraphQLCache} [options.cache={}] Cache to import; usually from a server side render.
 * @param {GraphQLCache} [options.cacheWrapper={}] wrapper cacheValue
 * @see [`reportCacheErrors`]{@link reportCacheErrors} to setup error reporting.
 * @example <caption>Construct a GraphQL client.</caption>
 * ```js
 * import { GraphQL } from 'graphql-svelte'
 *
 * const graphql = new GraphQL()
 * ```
 */
var GraphQL = /** @class */ (function () {
    function GraphQL(_a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, _c = _b.cache, cache = _c === void 0 ? {} : _c, cacheWrapper = _b.cacheWrapper;
        /**
         * Adds an event listener.
         * @kind function
         * @name GraphQL#on
         * @param {string} type Event type.
         * @param {Function} handler Event handler.
         * @see [`reportCacheErrors`]{@link reportCacheErrors} can be used with this to setup error reporting.
         */
        this.on = on;
        /**
         * Removes an event listener.
         * @kind function
         * @name GraphQL#off
         * @param {string} type Event type.
         * @param {Function} handler Event handler.
         */
        this.off = off;
        /**
         * Emits an event with details to listeners.
         * @param {string} type Event type.
         * @param {*} [details] Event details.
         * @ignore
         */
        this.emit = emit;
        /**
         * A map of loading GraphQL operations. You probably don’t need to interact
         * with this unless you’re implementing a server side rendering framework.
         * @name GraphQL#operations
         */
        this.operations = {};
        /**
         * Signals that [GraphQL cache]{@link GraphQL#cache} subscribers such as the
         * operation. Emits a [`GraphQL`]{@link GraphQL} instance `reload` event.
         * @kind function
         * @name GraphQL#reload
         * @param {GraphQLCacheKey} [exceptCacheKey] A [GraphQL cache]{@link GraphQL#cache} [key]{@link GraphQLCacheKey} for cache to exempt from reloading.
         * @example <caption>Reloading the [GraphQL cache]{@link GraphQL#cache}.</caption>
         * ```js
         * graphql.reload()
         * ```
         */
        this.reload = function (exceptCacheKey) {
            _this.emit('reload', { exceptCacheKey: exceptCacheKey });
        };
        /**
         * Resets the [GraphQL cache]{@link GraphQL#cache}, useful when a user logs
         * out. Emits a [`GraphQL`]{@link GraphQL} instance `reset` event.
         * @kind function
         * @name GraphQL#reset
         * @param {GraphQLCacheKey} [exceptCacheKey] A [GraphQL cache]{@link GraphQL#cache} [key]{@link GraphQLCacheKey} for cache to exempt from deletion. Useful for resetting cache after a mutation, preserving the mutation cache.
         * @example <caption>Resetting the [GraphQL cache]{@link GraphQL#cache}.</caption>
         * ```js
         * graphql.reset()
         * ```
         */
        this.reset = function (exceptCacheKey) {
            var cacheKeys = Object.keys(_this.cache);
            exceptCacheKey ? cacheKeys = cacheKeys.filter(function (hash) { return hash !== exceptCacheKey; }) : '';
            cacheKeys.forEach(function (cacheKey) { return delete _this.cache[cacheKey]; });
            // Emit cache updates after the entire cache has been updated, so logic in
            // listeners can assume cache for all queries is fresh and stable.
            _this.emit('reset', { exceptCacheKey: exceptCacheKey });
        };
        /**
         * Fetches a GraphQL operation.
         * @param {GraphQLFetchOptions} fetchOptions URL and options for [`fetch`](https://developer.mozilla.org/docs/Web/API/Fetch_API).
         * @param {GraphQLCacheKey} cacheKey [GraphQL cache]{@link GraphQL#cache} [key]{@link GraphQLCacheKey}.
         * @returns {Promise<GraphQLCacheValue>} A promise that resolves the [GraphQL cache]{@link GraphQL#cache} [value]{@link GraphQLCacheValue}.
         * @ignore
         */
        this.fetch = function (_a, cacheKey) {
            var url = _a.url, options = __rest(_a, ["url"]);
            var fetchResponse;
            var fetcher = typeof fetch === 'function'
                ? fetch
                : function () {
                    return Promise.reject(new Error('Global fetch API or polyfill unavailable.'));
                };
            var cacheValue = {};
            var cacheValuePromise = fetcher(url, options)
                .then(function (response) {
                fetchResponse = response;
                if (!response.ok)
                    cacheValue.httpError = {
                        status: response.status,
                        statusText: response.statusText,
                    };
                return response.json().then(function (_a) {
                    var errors = _a.errors, data = _a.data;
                    // JSON parse ok.
                    if (!errors && !data)
                        cacheValue.parseError = 'Malformed payload.';
                    if (errors)
                        cacheValue.graphQLErrors = errors;
                    if (data)
                        cacheValue.data = data;
                }, function (_a) {
                    var message = _a.message;
                    // JSON parse error.
                    cacheValue.parseError = message;
                });
            }, function (_a) {
                var message = _a.message;
                cacheValue.fetchError = message;
            })
                .then(function () {
                // Cache the operation.
                _this.cache[cacheKey] = _this.cacheWrapper ? _this.cacheWrapper(cacheValue) : cacheValue;
                // Clear the loaded operation.
                delete _this.operations[cacheKey];
                _this.emit('cache', {
                    cacheKey: cacheKey,
                    cacheValue: cacheValue,
                    // May be undefined if there was a fetch error.
                    response: fetchResponse,
                });
                return cacheValue;
            });
            _this.operations[cacheKey] = cacheValuePromise;
            _this.emit('fetch', { cacheKey: cacheKey, cacheValuePromise: cacheValuePromise });
            return cacheValuePromise;
        };
        /**
         * Loads or reuses an already loading GraphQL operation in
         * [GraphQL operations]{@link GraphQL#operations}. Emits a
         * [`GraphQL`]{@link GraphQL} instance `fetch` event if an already loading
         * operation isn’t reused, and a `cache` event once it’s loaded into the
         * [GraphQL cache]{@link GraphQL#cache}.
         * @kind function
         * @name GraphQL#operate
         * @param {object} options Options.
         * @param {GraphQLOperation} options.operation GraphQL operation.
         * @param {GraphQLFetchOptionsOverride} [options.fetchOptionsOverride] Overrides default GraphQL operation [`fetch` options]{@link GraphQLFetchOptions}.
         * @param {boolean} [options.reloadOnLoad=false] Should a [GraphQL reload]{@link GraphQL#reload} happen after the operation loads, excluding the loaded operation cache.
         * @param {boolean} [options.resetOnLoad=false] Should a [GraphQL reset]{@link GraphQL#reset} happen after the operation loads, excluding the loaded operation cache.
         * @returns {GraphQLOperationLoading} Loading GraphQL operation details.
         *
         */
        this.operate = function (_a) {
            var operation = _a.operation, fetchOptionsOverride = _a.fetchOptionsOverride, reloadOnLoad = _a.reloadOnLoad, resetOnLoad = _a.resetOnLoad;
            if (reloadOnLoad && resetOnLoad)
                throw new Error('operate() options “reloadOnLoad” and “resetOnLoad” can’t both be true.');
            var fetchOptions = graphqlFetchOptions_1.graphqlFetchOptions(operation);
            fetchOptionsOverride && fetchOptionsOverride(fetchOptions);
            var cacheKey = hashObject_1.hashObject(fetchOptions);
            var cacheValuePromise = 
            // Use an identical existing request or…
            _this.operations[cacheKey] ||
                // …make a fresh request.
                _this.fetch(fetchOptions, cacheKey);
            // Potential edge-case issue: Multiple identical queries with resetOnLoad
            // enabled will cause excessive resets.
            cacheValuePromise.then(function () {
                if (reloadOnLoad)
                    _this.reload(cacheKey);
                else if (resetOnLoad)
                    _this.reset(cacheKey);
            });
            return {
                cacheKey: cacheKey,
                cacheValue: _this.cache[cacheKey],
                cacheValuePromise: cacheValuePromise,
            };
        };
        this.cache = cache;
        this.cacheWrapper = cacheWrapper;
    }
    return GraphQL;
}());
exports.GraphQL = GraphQL;
//# sourceMappingURL=GraphQL.js.map