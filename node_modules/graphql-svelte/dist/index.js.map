{"version":3,"file":"index.js","sources":["../node_modules/mitt/src/index.ts","../src/graphqlFetchOptions.ts","../node_modules/@sindresorhus/fnv1a/index.js","../src/hashObject.ts","../src/GraphQL.ts","../src/reportCacheErrors.ts","../node_modules/backo/index.js","../node_modules/symbol-observable/es/index.js","../node_modules/symbol-observable/es/ponyfill.js","../src/SubscribeQL.ts","../src/svqlConfig.ts"],"sourcesContent":["export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = any> = (event?: T) => void;\nexport type WildcardHandler = (type: EventType, event?: any) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList = Array<Handler>;\nexport type WildCardEventHandlerList = Array<WildcardHandler>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap = Map<EventType, EventHandlerList | WildCardEventHandlerList>;\n\nexport interface Emitter {\n\tall: EventHandlerMap;\n\n\ton<T = any>(type: EventType, handler: Handler<T>): void;\n\ton(type: '*', handler: WildcardHandler): void;\n\n\toff<T = any>(type: EventType, handler: Handler<T>): void;\n\toff(type: '*', handler: WildcardHandler): void;\n\n\temit<T = any>(type: EventType, event?: T): void;\n\temit(type: '*', event?: any): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt(all?: EventHandlerMap): Emitter {\n\tall = all || new Map();\n\n\treturn {\n\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `\"*\"` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<T = any>(type: EventType, handler: Handler<T>) {\n\t\t\tconst handlers = all.get(type);\n\t\t\tconst added = handlers && handlers.push(handler);\n\t\t\tif (!added) {\n\t\t\t\tall.set(type, [handler]);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from, or `\"*\"`\n\t\t * @param {Function} handler Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<T = any>(type: EventType, handler: Handler<T>) {\n\t\t\tconst handlers = all.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `\"*\"` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing \"*\" handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<T = any>(type: EventType, evt: T) {\n\t\t\t((all.get(type) || []) as EventHandlerList).slice().map((handler) => { handler(evt); });\n\t\t\t((all.get('*') || []) as WildCardEventHandlerList).slice().map((handler) => { handler(type, evt); });\n\t\t}\n\t};\n}\n","import { GraphQLFetchOptions } from \"..\"\n\n/**\n * Gets default [`fetch` options]{@link GraphQLFetchOptions} for a\n * [GraphQL operation]{@link GraphQLOperation}.\n * @param {GraphQLOperation} operation GraphQL operation.\n * @returns {GraphQLFetchOptions} [`fetch`](https://developer.mozilla.org/docs/Web/API/Fetch_API) options.\n * @ignore\n */\nexport function graphqlFetchOptions(operation: any) {\n  const fetchOptions: GraphQLFetchOptions = {\n    url: '/graphql',\n    method: 'POST',\n    credentials:\"include\",\n    headers: { Accept: 'application/json', 'Content-Type': 'application/json' },\n  }\n  fetchOptions.body = JSON.stringify(operation)\n\n  return fetchOptions\n}\n","'use strict';\n\n// FNV_PRIMES and FNV_OFFSETS from\n// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param\n\nconst FNV_PRIMES = {\n\t32: 16777619n,\n\t64: 1099511628211n,\n\t128: 309485009821345068724781371n,\n\t256: 374144419156711147060143317175368453031918731002211n,\n\t512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,\n\t1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n\n};\n\nconst FNV_OFFSETS = {\n\t32: 2166136261n,\n\t64: 14695981039346656037n,\n\t128: 144066263297769815596495629667062367629n,\n\t256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,\n\t512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,\n\t1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n\n};\n\n// Legacy implementation for 32-bit + number types\nfunction fnv1a(string) {\n\t// Handle Unicode code points > 0x7f\n\tlet hash = Number(FNV_OFFSETS[32]);\n\tlet isUnicoded = false;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet characterCode = string.charCodeAt(i);\n\n\t\t// Non-ASCII characters trigger the Unicode escape logic\n\t\tif (characterCode > 0x7F && !isUnicoded) {\n\t\t\tstring = unescape(encodeURIComponent(string));\n\t\t\tcharacterCode = string.charCodeAt(i);\n\t\t\tisUnicoded = true;\n\t\t}\n\n\t\thash ^= characterCode;\n\t\thash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n\t}\n\n\treturn hash >>> 0;\n}\n\nfunction bigInt(string, {size = 32} = {}) {\n\tif (!FNV_PRIMES[size]) {\n\t\tthrow new Error('The `size` option must be one of 32, 64, 128, 256, 512, or 1024');\n\t}\n\n\tlet hash = FNV_OFFSETS[size];\n\tconst fnvPrime = FNV_PRIMES[size];\n\n\t// Handle Unicode code points > 0x7f\n\tlet isUnicoded = false;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tlet characterCode = string.charCodeAt(i);\n\n\t\t// Non-ASCII characters trigger the Unicode escape logic\n\t\tif (characterCode > 0x7F && !isUnicoded) {\n\t\t\tstring = unescape(encodeURIComponent(string));\n\t\t\tcharacterCode = string.charCodeAt(i);\n\t\t\tisUnicoded = true;\n\t\t}\n\n\t\thash ^= BigInt(characterCode);\n\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t}\n\n\treturn hash;\n}\n\nmodule.exports = fnv1a;\nmodule.exports.bigInt = bigInt;\n","import fnv1a from '@sindresorhus/fnv1a'\n\n/**\n * `JSON.stringify()` replacer that converts\n * [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData) instances\n * into a signature string.\n * @param {string} key Property name.\n * @param {*} value Property value.\n * @returns {*} Original value or replaced value if it was a `FormData` instance.\n * @ignore\n */\nfunction hashObjectReplacer(key: string | number, value: any) {\n  // Retrieve the original value, and not the possible .toJSON() version. When a\n  // value has a .toJSON() method, JSON.stringify provides the replacer\n  // function with output of that instead of the original value. FormData\n  // instances in browsers do not have a .toJSON() method, but some polyfill\n  // implementations might.\n  // See: https://github.com/octet-stream/form-data/issues/2\n  //@ts-ignore\n  const originalValue:FormData = this[key]\n\n  if (typeof FormData !== 'undefined' && originalValue instanceof FormData) {\n    // Value is a FormData instance. The idea is to return a string representing\n    // the unique signature of the form, to be hashed with the surrounding JSON\n    // string. Note that FormData forms can have multiple fields with the same\n    // name and that the order of form fields also determines the signature.\n\n    let signature: any\n    //@ts-ignore\n    const fields = originalValue.entries()\n\n    // Iterate manually using next() to avoid bulky for … of syntax\n    // transpilation.\n    let field = fields.next()\n    while (!field.done) {\n      const [name, value] = field.value\n\n      // If the value is a File or Blob instance, it should cast to a string\n      // like `[object File]`. It would be good if there was a way to signature\n      // File or Blob instances.\n      signature += `${name}${value}`\n\n      field = fields.next()\n    }\n\n    return signature\n  }\n\n  // Let JSON.stringify() stringify the value as normal.\n  return value\n}\n\n/**\n * Hashes an object.\n * @param {object} object A JSON serializable object that may contain [`FormData`](https://developer.mozilla.org/docs/Web/API/FormData) instances.\n * @returns {string} A hash.\n * @ignore\n */\nexport const hashObject = (object: any): string =>\n  fnv1a(JSON.stringify(object, hashObjectReplacer)).toString(36)\n","import mitt from 'mitt'\nimport { graphqlFetchOptions } from './graphqlFetchOptions'\nimport { hashObject } from './hashObject'\nimport { GraphQLCache, GraphQLCacheKey, GraphQLCacheValue, GraphQLFetchOptions } from '../index'\nconst { on, off, emit } = mitt()\n\n/**\n * A lightweight GraphQL client that caches queries and mutations.\n * @kind class\n * @name GraphQL\n * @param {object} [options={}] Options.\n * @param {GraphQLCache} [options.cache={}] Cache to import; usually from a server side render.\n * @param {GraphQLCache} [options.cacheWrapper={}] wrapper cacheValue\n * @see [`reportCacheErrors`]{@link reportCacheErrors} to setup error reporting.\n * @example <caption>Construct a GraphQL client.</caption>\n * ```js\n * import { GraphQL } from 'graphql-svelte'\n *\n * const graphql = new GraphQL()\n * ```\n */\nexport class GraphQL {\n\n  constructor({ cache = {}, cacheWrapper}: any = {}) {\n    this.cache = cache\n    this.cacheWrapper = cacheWrapper\n  }\n\n  /**\n    * wrapper for cache\n    * @kind function\n    * @name GraphQL#cacheWrapper\n    * @example```ts\n    *  import { writable } from 'svelte/store'\n    *\n    *  this.cacheWrapper(cacheValue)\n    * ```\n    */\n  cacheWrapper: Function\n  /**\n   * Adds an event listener.\n   * @kind function\n   * @name GraphQL#on\n   * @param {string} type Event type.\n   * @param {Function} handler Event handler.\n   * @see [`reportCacheErrors`]{@link reportCacheErrors} can be used with this to setup error reporting.\n   */\n  on = on\n\n  /**\n   * Removes an event listener.\n   * @kind function\n   * @name GraphQL#off\n   * @param {string} type Event type.\n   * @param {Function} handler Event handler.\n   */\n  off = off\n  /**\n   * Emits an event with details to listeners.\n   * @param {string} type Event type.\n   * @param {*} [details] Event details.\n   * @ignore\n   */\n  emit = emit\n  /**\n   * Cache of loaded GraphQL operations. You probably don’t need to interact\n   * with this unless you’re implementing a server side rendering framework.\n   * @kind member\n   * @name GraphQL#cache\n   * @type {GraphQLCache}\n   * @example <caption>Export cache as JSON.</caption>\n   * ```js\n   * const exportedCache = JSON.stringify(graphql.cache)\n   * ```\n   * @example <caption>Example cache JSON.</caption>\n   * ```json\n   * {\n   *   \"a1bCd2\": {\n   *      \"data\": {\n   *        \"viewer\": {\n   *          \"name\": \"Jayden Seric\"\n   *        }\n   *      }\n   *   }\n   * }\n   * ```\n   */\n  cache: GraphQLCache\n\n\n  /**\n   * A map of loading GraphQL operations. You probably don’t need to interact\n   * with this unless you’re implementing a server side rendering framework.\n   * @name GraphQL#operations\n   */\n  operations: Record<GraphQLCacheKey, Promise<GraphQLCacheValue>> = {}\n\n  /**\n   * Signals that [GraphQL cache]{@link GraphQL#cache} subscribers such as the\n   * operation. Emits a [`GraphQL`]{@link GraphQL} instance `reload` event.\n   * @kind function\n   * @name GraphQL#reload\n   * @param {GraphQLCacheKey} [exceptCacheKey] A [GraphQL cache]{@link GraphQL#cache} [key]{@link GraphQLCacheKey} for cache to exempt from reloading.\n   * @example <caption>Reloading the [GraphQL cache]{@link GraphQL#cache}.</caption>\n   * ```js\n   * graphql.reload()\n   * ```\n   */\n  reload = (exceptCacheKey: GraphQLCacheKey) => {\n    this.emit('reload', { exceptCacheKey })\n  }\n\n  /**\n   * Resets the [GraphQL cache]{@link GraphQL#cache}, useful when a user logs\n   * out. Emits a [`GraphQL`]{@link GraphQL} instance `reset` event.\n   * @kind function\n   * @name GraphQL#reset\n   * @param {GraphQLCacheKey} [exceptCacheKey] A [GraphQL cache]{@link GraphQL#cache} [key]{@link GraphQLCacheKey} for cache to exempt from deletion. Useful for resetting cache after a mutation, preserving the mutation cache.\n   * @example <caption>Resetting the [GraphQL cache]{@link GraphQL#cache}.</caption>\n   * ```js\n   * graphql.reset()\n   * ```\n   */\n  reset = (exceptCacheKey: string) => {\n    let cacheKeys = Object.keys(this.cache)\n\n    exceptCacheKey ? cacheKeys = cacheKeys.filter((hash) => hash !== exceptCacheKey) : ''\n\n    cacheKeys.forEach((cacheKey) => delete this.cache[cacheKey])\n\n    // Emit cache updates after the entire cache has been updated, so logic in\n    // listeners can assume cache for all queries is fresh and stable.\n    this.emit('reset', { exceptCacheKey })\n  }\n\n  /**\n   * Fetches a GraphQL operation.\n   * @param {GraphQLFetchOptions} fetchOptions URL and options for [`fetch`](https://developer.mozilla.org/docs/Web/API/Fetch_API).\n   * @param {GraphQLCacheKey} cacheKey [GraphQL cache]{@link GraphQL#cache} [key]{@link GraphQLCacheKey}.\n   * @returns {Promise<GraphQLCacheValue>} A promise that resolves the [GraphQL cache]{@link GraphQL#cache} [value]{@link GraphQLCacheValue}.\n   * @ignore\n   */\n  fetch = ({ url, ...options }: GraphQLFetchOptions, cacheKey: GraphQLCacheKey): Promise<GraphQLCacheValue> => {\n    let fetchResponse: any\n\n    const fetcher =\n      typeof fetch === 'function'\n        ? fetch\n        : () =>\n          Promise.reject(\n            new Error('Global fetch API or polyfill unavailable.')\n          )\n    const cacheValue: any = {}\n    const cacheValuePromise = fetcher(url, options)\n      .then(\n        (response) => {\n          fetchResponse = response\n\n          if (!response.ok)\n            cacheValue.httpError = {\n              status: response.status,\n              statusText: response.statusText,\n            }\n\n          return response.json().then(\n            ({ errors, data }) => {\n              // JSON parse ok.\n              if (!errors && !data) cacheValue.parseError = 'Malformed payload.'\n              if (errors) cacheValue.graphQLErrors = errors\n              if (data) cacheValue.data = data\n            },\n            ({ message }) => {\n              // JSON parse error.\n              cacheValue.parseError = message\n            }\n          )\n        },\n        ({ message }) => {\n          cacheValue.fetchError = message\n        }\n      )\n      \n      .then(() => {\n        // Cache the operation.\n        this.cache[cacheKey] =  this.cacheWrapper ? this.cacheWrapper(cacheValue):cacheValue\n\n        // Clear the loaded operation.\n        delete this.operations[cacheKey];\n\n        this.emit('cache', {\n          cacheKey,\n          cacheValue,\n          // May be undefined if there was a fetch error.\n          response: fetchResponse,\n        })\n\n        return cacheValue\n      })\n\n    this.operations[cacheKey] = cacheValuePromise\n\n    this.emit('fetch', { cacheKey, cacheValuePromise })\n\n    return cacheValuePromise\n  }\n\n  /**\n   * Loads or reuses an already loading GraphQL operation in\n   * [GraphQL operations]{@link GraphQL#operations}. Emits a\n   * [`GraphQL`]{@link GraphQL} instance `fetch` event if an already loading\n   * operation isn’t reused, and a `cache` event once it’s loaded into the\n   * [GraphQL cache]{@link GraphQL#cache}.\n   * @kind function\n   * @name GraphQL#operate\n   * @param {object} options Options.\n   * @param {GraphQLOperation} options.operation GraphQL operation.\n   * @param {GraphQLFetchOptionsOverride} [options.fetchOptionsOverride] Overrides default GraphQL operation [`fetch` options]{@link GraphQLFetchOptions}.\n   * @param {boolean} [options.reloadOnLoad=false] Should a [GraphQL reload]{@link GraphQL#reload} happen after the operation loads, excluding the loaded operation cache.\n   * @param {boolean} [options.resetOnLoad=false] Should a [GraphQL reset]{@link GraphQL#reset} happen after the operation loads, excluding the loaded operation cache.\n   * @returns {GraphQLOperationLoading} Loading GraphQL operation details.\n   *\n   */\n  operate = ({ operation, fetchOptionsOverride, reloadOnLoad, resetOnLoad }: any) => {\n\n    if (reloadOnLoad && resetOnLoad) throw new Error('operate() options “reloadOnLoad” and “resetOnLoad” can’t both be true.')\n\n    const fetchOptions = graphqlFetchOptions(operation)\n     fetchOptionsOverride && fetchOptionsOverride(fetchOptions)\n    const cacheKey = hashObject(fetchOptions)\n    const cacheValuePromise =\n      // Use an identical existing request or…\n      this.operations[cacheKey] ||\n      // …make a fresh request.\n      this.fetch(fetchOptions, cacheKey)\n\n\n\n    // Potential edge-case issue: Multiple identical queries with resetOnLoad\n    // enabled will cause excessive resets.\n    cacheValuePromise.then(() => {\n      if (reloadOnLoad) this.reload(cacheKey)\n      else if (resetOnLoad) this.reset(cacheKey)\n    })\n\n    return {\n      cacheKey,\n      cacheValue: this.cache[cacheKey],\n      cacheValuePromise,\n    }\n  }\n}\n","/**\n * A [`GraphQL`]{@link GraphQL} `cache` event handler that reports\n * [`fetch`](https://developer.mozilla.org/docs/Web/API/Fetch_API), HTTP, parse\n * and GraphQL errors via `console.log()`. In a browser environment the grouped\n * error details are expandable.\n * @kind function\n * @name reportCacheErrors\n * @param {object} data [`GraphQL`]{@link GraphQL} `cache` event data.\n * @param {GraphQLCacheKey} data.cacheKey [GraphQL cache]{@link GraphQL#cache} [key]{@link GraphQLCacheKey}.\n * @param {GraphQLCacheKey} data.cacheValue [GraphQL cache]{@link GraphQL#cache} [value]{@link GraphQLCacheValue}.\n * @example <caption>[`GraphQL`]{@link GraphQL} initialized to report cache errors.</caption>\n * ```js\n * import { GraphQL, reportCacheErrors } from 'graphql-react'\n *\n * const graphql = new GraphQL()\n * graphql.on('cache', reportCacheErrors)\n * ```\n */\nexport function reportCacheErrors({\n  cacheKey,\n  cacheValue: { fetchError, httpError, parseError, graphQLErrors },\n}: any) {\n  if (fetchError || httpError || parseError || graphQLErrors) {\n    // eslint-disable-next-line no-console\n    console.groupCollapsed(`GraphQL cache errors for key “${cacheKey}”:`)\n\n    if (fetchError) {\n      // eslint-disable-next-line no-console\n      console.groupCollapsed('Fetch:')\n\n      // eslint-disable-next-line no-console\n      console.log(fetchError)\n\n      // eslint-disable-next-line no-console\n      console.groupEnd()\n    }\n\n    if (httpError) {\n      // eslint-disable-next-line no-console\n      console.groupCollapsed('HTTP:')\n\n      // eslint-disable-next-line no-console\n      console.log(`Status: ${httpError.status}`)\n\n      // eslint-disable-next-line no-console\n      console.log(`Text: ${httpError.statusText}`)\n\n      // eslint-disable-next-line no-console\n      console.groupEnd()\n    }\n\n    if (parseError) {\n      // eslint-disable-next-line no-console\n      console.groupCollapsed('Parse:')\n\n      // eslint-disable-next-line no-console\n      console.log(parseError)\n\n      // eslint-disable-next-line no-console\n      console.groupEnd()\n    }\n\n    if (graphQLErrors) {\n      // eslint-disable-next-line no-console\n      console.groupCollapsed('GraphQL:')\n\n      graphQLErrors.forEach(({ message }: any) =>\n        // eslint-disable-next-line no-console\n        console.log(message)\n      )\n\n      // eslint-disable-next-line no-console\n      console.groupEnd()\n    }\n\n    // eslint-disable-next-line no-console\n    console.groupEnd()\n  }\n}\n","\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\n\t\t\t// This just needs to be something that won't trample other user's Symbol.for use\n\t\t\t// It also will guide people to the source of their issues, if this is problematic.\n\t\t\t// META: It's a resource locator!\n\t\t\tresult = Symbol.for('https://github.com/benlesh/symbol-observable');\n\t\t\ttry {\n\t\t\t\tSymbol.observable = result;\n\t\t\t} catch (err) {\n\t\t\t\t// Do nothing. In some environments, users have frozen `Symbol` for security reasons,\n\t\t\t\t// if it is frozen assigning to it will throw. In this case, we don't care, because\n\t\t\t\t// they will need to use the returned value from the ponyfill.\n\t\t\t}\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","//@ts-ignore\nimport Backoff from \"backo\";\nimport mitt, { Emitter } from \"mitt\";\nconst { on, off, emit } = mitt();\nimport $$observable from \"symbol-observable\";\nimport { WSOptions } from \"..\";\n\nconst WS_TIMEOUT = 30000;\n\nfunction isString(value: any) {\n  return typeof value === \"string\";\n}\nfunction isObject(value: null) {\n  return value !== null && typeof value === \"object\";\n}\n\nexport class SubscriptionClient {\n  wsImpl: {\n    new(url: string, protocols?: string | string[]): WebSocket;\n    prototype: WebSocket;\n    readonly CLOSED: number;\n    readonly CLOSING: number;\n    readonly CONNECTING: number;\n    readonly OPEN: number;\n  };\n  connectionCallback: any;\n  url: any;\n  operations: any = {};\n  nextOperationId: number;\n  wsTimeout: any;\n  unsentMessagesQueue: any[];\n  reconnect: any;\n  reconnecting: boolean;\n  reconnectionAttempts: any;\n  lazy: boolean;\n  inactivityTimeout: any;\n  closedByUser: boolean;\n  backoff: any;\n  eventEmitter = emit;\n  client: any;\n  maxConnectTimeGenerator: any;\n  connectionParams: () => Promise<unknown>;\n  checkConnectionIntervalId: any;\n  maxConnectTimeoutId: any;\n  tryReconnectTimeoutId: any;\n  inactivityTimeoutId: any;\n  wasKeepAliveReceived: any;\n  constructor(url: any, options: any = {}) {\n    const {\n      connectionCallback = undefined,\n      connectionParams = {},\n      timeout = WS_TIMEOUT,\n      reconnect = false,\n      reconnectionAttempts = Infinity,\n      lazy = false,\n      inactivityTimeout = 0,\n    } = options || {};\n\n    this.wsImpl = WebSocket;\n    this.connectionCallback = connectionCallback;\n    this.url = url;\n    this.operations = {};\n    this.nextOperationId = 0;\n    this.wsTimeout = timeout;\n    this.unsentMessagesQueue = [];\n    this.reconnect = reconnect;\n    this.reconnecting = false;\n    this.reconnectionAttempts = reconnectionAttempts;\n    this.lazy = !!lazy;\n    this.inactivityTimeout = inactivityTimeout;\n    this.closedByUser = false;\n    this.backoff = new Backoff({ jitter: 0.5 });\n    this.client = null;\n    this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();\n    this.connectionParams = this.getConnectionParams(connectionParams);\n\n    if (!this.lazy) {\n      this.connect();\n    }\n  }\n  get status() {\n    if (this.client === null) {\n      return this.wsImpl.CLOSED;\n    }\n\n    return this.client.readyState;\n  }\n\n  close(isForced = true, closedByUser = true) {\n    this.clearInactivityTimeout();\n    if (this.client !== null) {\n      this.closedByUser = closedByUser;\n\n      if (isForced) {\n        this.clearCheckConnectionInterval();\n        this.clearMaxConnectTimeout();\n        this.clearTryReconnectTimeout();\n        this.unsubscribeAll();\n        this.sendMessage(undefined, \"connection_terminate\", null);\n      }\n\n      this.client.close();\n      this.client = null;\n      this.eventEmitter(\"disconnected\");\n\n      if (!isForced) {\n        this.tryReconnect();\n      }\n    }\n  }\n\n  request(request: { query: any; variables?: object; }) {\n    const getObserver = this.getObserver.bind(this);\n    const executeOperation = this.executeOperation.bind(this);\n    const unsubscribe = this.unsubscribe.bind(this);\n\n    let opId: string | null;\n\n    this.clearInactivityTimeout();\n\n    return {\n      //@ts-ignore\n      [$$observable[\"default\"] ? $$observable[\"default\"] : $$observable]() {\n        return this;\n      },\n      subscribe(observerOrNext?: any, onError?: any, onComplete?: any) {\n        const observer = getObserver(observerOrNext, onError, onComplete);\n\n        //@ts-ignore\n        opId = executeOperation(request, (error, result) => {\n          if (error === null && result === null) {\n            if (observer.complete) {\n              observer.complete();\n            }\n          } else if (error) {\n            if (observer.error) {\n              observer.error(error[0]);\n            }\n          } else {\n            if (observer.next) {\n              observer.next(result);\n            }\n          }\n        });\n\n        return {\n          unsubscribe: () => {\n            if (opId) {\n              unsubscribe(opId);\n              opId = null;\n            }\n          },\n        };\n      },\n    };\n  }\n\n  on(eventName: string, callback: any, context?:any) {\n    on(eventName, callback)\n  }\n\n  onConnected(callback: any, context?:any) {\n    return this.on('connected', callback, context)\n  }\n\n  onConnecting(callback: any, context?:any) {\n    return this.on('connecting', callback, context)\n  }\n\n  onDisconnected(callback: any, context?:any) {\n    return this.on('disconnected', callback, context)\n  }\n\n  onReconnected(callback: any, context?:any) {\n    return this.on('reconnected', callback, context)\n  }\n\n  onReconnecting(callback: any, context?:any) {\n    return this.on('reconnecting', callback, context)\n  }\n\n  onError(callback: any, context?:any) {\n    return this.on('error', callback, context)\n  }\n\n\n  unsubscribeAll() {\n    Object.keys(this.operations).forEach((subId) => {\n      this.unsubscribe(subId);\n    });\n  }\n\n  getConnectionParams(connectionParams: unknown) {\n    return () =>\n      new Promise((resolve, reject) => {\n        if (typeof connectionParams === \"function\") {\n          try {\n            return resolve(connectionParams(null));\n          } catch (error) {\n            return reject(error);\n          }\n        }\n\n        resolve(connectionParams);\n      });\n  }\n\n  executeOperation(options: any, handler: (arg0: any) => void) {\n    if (this.client === null) {\n      this.connect();\n    }\n\n    const opId = this.generateOperationId();\n    this.operations[opId] = { options: options, handler };\n\n    try {\n      this.checkOperationOptions(options, handler);\n      if (this.operations[opId]) {\n        this.operations[opId] = { options, handler };\n        this.sendMessage(opId, \"start\", options);\n      }\n    } catch (error) {\n      this.unsubscribe(opId);\n      handler(this.formatErrors(error));\n    }\n\n    return opId;\n  }\n\n  getObserver(observerOrNext: any, error?: (arg0: any) => any, complete?: () => any) {\n    if (typeof observerOrNext === \"function\") {\n      return {\n        next: (v: any) => observerOrNext(v),\n        error: (e: any) => error && error(e),\n        complete: () => complete && complete(),\n      };\n    }\n    return observerOrNext;\n  }\n\n  createMaxConnectTimeGenerator() {\n    const minValue = 1000;\n    const maxValue = this.wsTimeout;\n    return new Backoff({\n      min: minValue,\n      max: maxValue,\n      factor: 1.2,\n    });\n  }\n\n  clearCheckConnectionInterval() {\n    if (this.checkConnectionIntervalId) {\n      clearInterval(this.checkConnectionIntervalId);\n      this.checkConnectionIntervalId = null;\n    }\n  }\n\n  clearMaxConnectTimeout() {\n    if (this.maxConnectTimeoutId) {\n      clearTimeout(this.maxConnectTimeoutId);\n      this.maxConnectTimeoutId = null;\n    }\n  }\n\n  clearTryReconnectTimeout() {\n    if (this.tryReconnectTimeoutId) {\n      clearTimeout(this.tryReconnectTimeoutId);\n      this.tryReconnectTimeoutId = null;\n    }\n  }\n\n  clearInactivityTimeout() {\n    if (this.inactivityTimeoutId) {\n      clearTimeout(this.inactivityTimeoutId);\n      this.inactivityTimeoutId = null;\n    }\n  }\n\n  setInactivityTimeout() {\n    if (\n      this.inactivityTimeout > 0 &&\n      Object.keys(this.operations).length === 0\n    ) {\n      this.inactivityTimeoutId = setTimeout(() => {\n        if (Object.keys(this.operations).length === 0) {\n          this.close();\n        }\n      }, this.inactivityTimeout);\n    }\n  }\n\n  checkOperationOptions(options: { query: any; variables: any; operationName: any; }, handler: any) {\n    const { query, variables, operationName } = options;\n    if (!query) {\n      throw new Error(\"Must provide a query.\");\n    }\n    if (!handler) {\n      throw new Error(\"Must provide an handler.\");\n    }\n    if (\n      !isString(query) ||\n      (operationName && !isString(operationName)) ||\n      (variables && !isObject(variables))\n    ) {\n      throw new Error(\n        \"Incorrect option types. query must be a string,\" +\n        \"`operationName` must be a string, and `variables` must be an object.\"\n      );\n    }\n  }\n\n  buildMessage(id: any, type: string, payload: { query: string; variables: Object }) {\n    const payloadToReturn =\n      payload && payload.query\n        ? Object.assign({}, payload, {\n          query: payload.query,\n        })\n        : payload;\n    return {\n      id,\n      type,\n      payload: payloadToReturn,\n    };\n  }\n\n  formatErrors(errors: any): any {\n    if (Array.isArray(errors)) {\n      return errors;\n    }\n    if (errors && errors.errors) {\n      return this.formatErrors(errors.errors);\n    }\n    if (errors && errors.message) {\n      return [errors];\n    }\n    return [\n      {\n        name: \"FormatedError\",\n        message: \"Unknown error\",\n        originalError: errors,\n      },\n    ];\n  }\n\n  sendMessage(id: string | undefined, type: string, payload: any) {\n    this.sendMessageRaw(this.buildMessage(id, type, payload));\n  }\n\n  // send message, or queue it if connection is not open\n  sendMessageRaw(message: { id: any; type: any; payload: any; }) {\n    switch (this.status) {\n      case this.wsImpl.OPEN:\n        const serializedMessage = JSON.stringify(message);\n        try {\n          JSON.parse(serializedMessage);\n        } catch (error) {\n          this.eventEmitter(\n            \"error\",\n            new Error(`Message must be JSON-serializable. Got: ${message}`)\n          );\n        }\n        this.client.send(serializedMessage);\n        break;\n      case this.wsImpl.CONNECTING:\n        this.unsentMessagesQueue.push(message);\n        break;\n      default:\n        if (!this.reconnecting) {\n          this.eventEmitter(\n            \"error\",\n            new Error(\n              \"A message was not sent because socket is not connected, is closing or \" +\n              \"is already closed. Message was: \" +\n              JSON.stringify(message)\n            )\n          );\n        }\n    }\n  }\n\n  generateOperationId() {\n    return String(++this.nextOperationId);\n  }\n\n  tryReconnect() {\n    if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {\n      return;\n    }\n\n    if (!this.reconnecting) {\n      Object.keys(this.operations).forEach((key) => {\n        this.unsentMessagesQueue.push(\n          this.buildMessage(key, \"start\", this.operations[key].options)\n        );\n      });\n      this.reconnecting = true;\n    }\n\n    this.clearTryReconnectTimeout();\n\n    const delay = this.backoff.duration();\n    this.tryReconnectTimeoutId = setTimeout(() => {\n      this.connect();\n    }, delay);\n  }\n\n  flushUnsentMessagesQueue() {\n    this.unsentMessagesQueue.forEach((message) => {\n      this.sendMessageRaw(message);\n    });\n    this.unsentMessagesQueue = [];\n  }\n\n  checkConnection() {\n    if (this.wasKeepAliveReceived) {\n      this.wasKeepAliveReceived = false;\n      return;\n    }\n\n    if (!this.reconnecting) {\n      this.close(false, true);\n    }\n  }\n\n  checkMaxConnectTimeout() {\n    this.clearMaxConnectTimeout();\n\n    // Max timeout trying to connect\n    this.maxConnectTimeoutId = setTimeout(() => {\n      if (this.status !== this.wsImpl.OPEN) {\n        this.reconnecting = true;\n        this.close(false, true);\n      }\n    }, this.maxConnectTimeGenerator.duration());\n  }\n\n  connect() {\n    this.client = new WebSocket(this.url, \"graphql-ws\");\n\n    this.checkMaxConnectTimeout();\n\n    this.client.addEventListener(\"open\", async () => {\n\n      if (this.status === this.wsImpl.OPEN) {\n        this.clearMaxConnectTimeout();\n        this.closedByUser = false;\n        this.eventEmitter(\n          this.reconnecting ? \"reconnecting\" : \"connecting\"\n        );\n\n        try {\n          const connectionParams = await this.connectionParams();\n          // Send connection_init message, no need to wait for connection to success (reduce roundtrips)\n          this.sendMessage(undefined, \"connection_init\", connectionParams);\n          this.flushUnsentMessagesQueue();\n        } catch (error) {\n          this.sendMessage(undefined, \"connection_error\", error);\n          this.eventEmitter('error', error)\n          this.flushUnsentMessagesQueue();\n        }\n      }\n    });\n\n    this.client.onclose = () => {\n      if (!this.closedByUser) {\n        this.close(false, false);\n      }\n    };\n\n    this.client.addEventListener(\"error\", (error: any) => {\n      // Capture and ignore errors to prevent unhandled exceptions, wait for\n      // onclose to fire before attempting a reconnect.\n      this.eventEmitter(\"connection_error\", error);\n    });\n\n    this.client.addEventListener(\"message\", ({ data }: any) => {\n      this.processReceivedData(data);\n    });\n  }\n\n  processReceivedData(receivedData: string) {\n    let parsedMessage;\n    let opId;\n\n    try {\n      parsedMessage = JSON.parse(receivedData);\n      opId = parsedMessage.id;\n    } catch (error) {\n      throw new Error(`Message must be JSON-parseable. Got: ${receivedData}`);\n    }\n    if (\n      [\"data\", \"complete\", \"error\"].includes(parsedMessage.type) &&\n      !this.operations[opId]\n    ) {\n      this.unsubscribe(opId);\n\n      return;\n    }\n\n    switch (parsedMessage.type) {\n      case \"connection_error\":\n        if (this.connectionCallback) {\n          this.connectionCallback(parsedMessage.payload);\n        }\n        break;\n\n      case \"connection_ack\":\n        this.eventEmitter(this.reconnecting ? \"reconnected\" : \"connected\");\n        this.reconnecting = false;\n        this.backoff.reset();\n        this.maxConnectTimeGenerator.reset();\n\n        if (this.connectionCallback) {\n          this.connectionCallback();\n        }\n        break;\n\n      case \"complete\":\n        this.operations[opId].handler(null, null);\n        delete this.operations[opId];\n        break;\n\n      case \"error\":\n        this.eventEmitter(\"error\", this.formatErrors(parsedMessage.payload))\n        this.operations[opId].handler(\n          this.formatErrors(parsedMessage.payload),\n          null\n        );\n        delete this.operations[opId];\n        break;\n\n      case \"data\":\n        const parsedPayload = !parsedMessage.payload.errors\n          ? parsedMessage.payload\n          : {\n            ...parsedMessage.payload,\n            errors: this.formatErrors(parsedMessage.payload.errors),\n          };\n        this.operations[opId].handler(null, parsedPayload);\n        break;\n\n      case \"ka\":\n        const firstKA = typeof this.wasKeepAliveReceived === \"undefined\";\n        this.wasKeepAliveReceived = true;\n\n        if (firstKA) {\n          this.checkConnection();\n        }\n\n        if (this.checkConnectionIntervalId) {\n          clearInterval(this.checkConnectionIntervalId);\n          this.checkConnection();\n        }\n        this.checkConnectionIntervalId = setInterval(\n          this.checkConnection.bind(this),\n          this.wsTimeout\n        );\n        break;\n\n      default:\n        throw new Error(\"Invalid message type!\");\n    }\n  }\n\n  unsubscribe(opId: string) {\n    if (this.operations[opId]) {\n      delete this.operations[opId];\n      this.setInactivityTimeout();\n      this.sendMessage(opId, \"stop\", undefined);\n    }\n  }\n}\n\nexport function SubscribeQL(url: any, options: WSOptions) {\n  return new SubscriptionClient(url, options);\n}\n","import { GraphQLFetchOptions, queryType, graphqlOptions } from '..'\nimport { GraphQL } from './GraphQL'\nimport { graphqlFetchOptions } from './graphqlFetchOptions'\nimport { hashObject } from './hashObject'\nimport { SubscribeQL } from './SubscribeQL'\n//@ts-ignore\nexport let client: {\n  graphql: GraphQL;\n  subscription({ query, variables }: { query: string, variables?: object }): {\n    [x: number]: () => any;\n    subscribe(observerOrNext?: any, onError?: any, onComplete?: any): {\n      unsubscribe: () => void;\n    };\n  };\n  sub: any;\n  mutate({ query, variables, cache, key }: queryType): Promise<any>;\n  query({ query, variables, cache, key }: queryType): Promise<any>;\n} = {}\nlet _headers = {\n  'content-type': 'application/json',\n}\n\nexport function setHeaders(headers: any) {\n  _headers = headers\n}\n\nexport function headers() {\n  return _headers\n}\n\n\n\n/**\n * * Gets default client {@link svqlConfig} for a\n * [GraphQL Client]{@link svqlConfig}.\n * @param {*} url\n * @param {*} wsUrl\n * @param {{\n *   connectionCallback:string\n *   connectionParams:Object,\n *   timeout:number,\n *   reconnect:boolean,\n *   reconnectionAttempts:number,\n *   lazy:boolean,\n *   inactivityTimeout:number\n *   }} options\n */\nexport function getClient({ url, wsUrl, wsOptions = {}, graphqlOptions = {} }: graphqlOptions) {\n  const graphql = new GraphQL(graphqlOptions)\n\n  const fetchOptionsOverride = (_options: GraphQLFetchOptions) => {\n    ; (_options.url = url), (_options.headers = headers())\n  }\n\n  function getOrSet(\n    fetchOptionsOverride: Function,\n    data: any,\n    withCache: boolean,\n    getKey = (key: any) => key\n  ) {\n    const fetchOptions = graphqlFetchOptions({ ...data })\n\n    fetchOptionsOverride(fetchOptions)\n    const has = hashObject(fetchOptions)\n    getKey(has)\n    if (graphql.cache[has] && graphql.cache[has].graphQLErrors) {\n      delete graphql.cache[has]\n    }\n\n    if (graphql.cache[has] && withCache) {\n      return new Promise((res) => res(graphql.cache[has]))\n    }\n\n    const pending = graphql.operate({\n      fetchOptionsOverride,\n      operation: {\n        ...data,\n      },\n    })\n\n    return pending.cacheValuePromise.then((r) => graphql.cache[has])\n  }\n  /**\n   * @param {event:string,callback:Function } client.on\n   */\n  client.graphql = graphql\n  if (wsUrl) {\n    const initSub = (ws: any) =>\n      SubscribeQL(wsUrl, {\n        reconnect: ws.reconnect || true,\n        lazy: ws.lazy || true,\n        ...(ws.connectionParams\n          ? { connectionParams: ws.connectionParams }\n          : {\n            connectionParams: () => {\n              return { headers: headers() }\n            },\n          }),\n      })\n    let sub = initSub(wsOptions)\n\n    /**\n     *\n     * @param { query:string, variables:Object } client.subscription\n     */\n    client.subscription = ({ query, variables }) =>\n      sub.request({ query, variables })\n    /**\n     * @param {SubscribeQL} client.sub\n     */\n    client.sub = sub\n  }\n  /**\n   *\n   * @param {string} query\n   * @param {Object} variables\n   * @param {boolean} cache\n   * @returns {Promise}\n   */\n  client.mutate = ({ query, variables, cache = false, key }: queryType): Promise<any> =>\n    getOrSet(fetchOptionsOverride, { query, variables }, cache, key)\n  /**\n   *\n   * @param {string} query\n   * @param {Object} variables\n   * @param {boolean} cache\n   * @returns {Promise}\n   */\n\n  client.query = ({ query, variables, cache = true, key }: queryType): Promise<any> =>\n    getOrSet(fetchOptionsOverride, { query, variables }, cache, key)\n\n  return client\n}\n"],"names":["all","Map","on","type","handler","handlers","get","push","set","off","splice","indexOf","emit","evt","slice","map","graphqlFetchOptions","operation","fetchOptions","url","method","credentials","headers","Accept","Content-Type","body","JSON","stringify","FNV_PRIMES","32","64","128","256","512","1024","FNV_OFFSETS","string","hash","Number","isUnicoded","i","length","characterCode","charCodeAt","unescape","encodeURIComponent","size","Error","fnvPrime","BigInt","asUintN","hashObjectReplacer","key","value","originalValue","this","FormData","signature","fields","entries","field","next","done","_a","hashObject","object","fnv1a","toString","mitt","_b","_c","cache","cacheWrapper","exceptCacheKey","_this","cacheKeys","Object","keys","filter","forEach","cacheKey","fetchResponse","options","fetcher","fetch","Promise","reject","cacheValue","cacheValuePromise","then","response","ok","httpError","status","statusText","json","errors","data","parseError","graphQLErrors","message","fetchError","operations","fetchOptionsOverride","reloadOnLoad","resetOnLoad","reload","reset","reportCacheErrors","console","groupCollapsed","log","groupEnd","Backoff","opts","ms","min","max","factor","jitter","attempts","prototype","duration","Math","pow","rand","random","deviation","floor","result","root","Symbol","observable","for","err","ponyfill","self","window","global","module","Function","isString","connectionCallback","undefined","connectionParams","_d","timeout","_e","reconnect","_f","reconnectionAttempts","Infinity","_g","lazy","_h","inactivityTimeout","wsImpl","WebSocket","nextOperationId","wsTimeout","unsentMessagesQueue","reconnecting","closedByUser","backoff","client","maxConnectTimeGenerator","createMaxConnectTimeGenerator","getConnectionParams","connect","SubscriptionClient","CLOSED","readyState","isForced","clearInactivityTimeout","clearCheckConnectionInterval","clearMaxConnectTimeout","clearTryReconnectTimeout","unsubscribeAll","sendMessage","close","eventEmitter","tryReconnect","request","opId","getObserver","bind","executeOperation","unsubscribe","$$observable","observerOrNext","onError","onComplete","observer","error","complete","eventName","callback","context","subId","resolve","generateOperationId","checkOperationOptions","formatErrors","v","e","maxValue","checkConnectionIntervalId","clearInterval","maxConnectTimeoutId","clearTimeout","tryReconnectTimeoutId","inactivityTimeoutId","setTimeout","query","variables","operationName","id","payload","assign","Array","isArray","name","originalError","sendMessageRaw","buildMessage","OPEN","serializedMessage","parse","send","CONNECTING","String","delay","wasKeepAliveReceived","checkMaxConnectTimeout","addEventListener","flushUnsentMessagesQueue","error_1","onclose","processReceivedData","receivedData","parsedMessage","includes","parsedPayload","firstKA","checkConnection","setInterval","setInactivityTimeout","SubscribeQL","_headers","content-type","ws","wsUrl","wsOptions","graphql","GraphQL","_options","getOrSet","withCache","getKey","has","res","operate","r","sub_1","subscription","sub","mutate"],"mappings":"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"}