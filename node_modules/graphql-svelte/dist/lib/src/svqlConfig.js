"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClient = exports.headers = exports.setHeaders = exports.client = void 0;
var GraphQL_1 = require("./GraphQL");
var graphqlFetchOptions_1 = require("./graphqlFetchOptions");
var hashObject_1 = require("./hashObject");
var SubscribeQL_1 = require("./SubscribeQL");
//@ts-ignore
exports.client = {};
var _headers = {
    'content-type': 'application/json',
};
function setHeaders(headers) {
    _headers = headers;
}
exports.setHeaders = setHeaders;
function headers() {
    return _headers;
}
exports.headers = headers;
/**
 * * Gets default client {@link svqlConfig} for a
 * [GraphQL Client]{@link svqlConfig}.
 * @param {*} url
 * @param {*} wsUrl
 * @param {{
 *   connectionCallback:string
 *   connectionParams:Object,
 *   timeout:number,
 *   reconnect:boolean,
 *   reconnectionAttempts:number,
 *   lazy:boolean,
 *   inactivityTimeout:number
 *   }} options
 */
function getClient(_a) {
    var url = _a.url, wsUrl = _a.wsUrl, _b = _a.wsOptions, wsOptions = _b === void 0 ? {} : _b, _c = _a.graphqlOptions, graphqlOptions = _c === void 0 ? {} : _c;
    var graphql = new GraphQL_1.GraphQL(graphqlOptions);
    var fetchOptionsOverride = function (_options) {
        ;
        (_options.url = url), (_options.headers = headers());
    };
    function getOrSet(fetchOptionsOverride, data, withCache, getKey) {
        if (getKey === void 0) { getKey = function (key) { return key; }; }
        var fetchOptions = graphqlFetchOptions_1.graphqlFetchOptions(__assign({}, data));
        fetchOptionsOverride(fetchOptions);
        var has = hashObject_1.hashObject(fetchOptions);
        getKey(has);
        if (graphql.cache[has] && graphql.cache[has].graphQLErrors) {
            delete graphql.cache[has];
        }
        if (graphql.cache[has] && withCache) {
            return new Promise(function (res) { return res(graphql.cache[has]); });
        }
        var pending = graphql.operate({
            fetchOptionsOverride: fetchOptionsOverride,
            operation: __assign({}, data),
        });
        return pending.cacheValuePromise.then(function (r) { return graphql.cache[has]; });
    }
    /**
     * @param {event:string,callback:Function } client.on
     */
    exports.client.graphql = graphql;
    if (wsUrl) {
        var initSub = function (ws) {
            return SubscribeQL_1.SubscribeQL(wsUrl, __assign({ reconnect: ws.reconnect || true, lazy: ws.lazy || true }, (ws.connectionParams
                ? { connectionParams: ws.connectionParams }
                : {
                    connectionParams: function () {
                        return { headers: headers() };
                    },
                })));
        };
        var sub_1 = initSub(wsOptions);
        /**
         *
         * @param { query:string, variables:Object } client.subscription
         */
        exports.client.subscription = function (_a) {
            var query = _a.query, variables = _a.variables;
            return sub_1.request({ query: query, variables: variables });
        };
        /**
         * @param {SubscribeQL} client.sub
         */
        exports.client.sub = sub_1;
    }
    /**
     *
     * @param {string} query
     * @param {Object} variables
     * @param {boolean} cache
     * @returns {Promise}
     */
    exports.client.mutate = function (_a) {
        var query = _a.query, variables = _a.variables, _b = _a.cache, cache = _b === void 0 ? false : _b, key = _a.key;
        return getOrSet(fetchOptionsOverride, { query: query, variables: variables }, cache, key);
    };
    /**
     *
     * @param {string} query
     * @param {Object} variables
     * @param {boolean} cache
     * @returns {Promise}
     */
    exports.client.query = function (_a) {
        var query = _a.query, variables = _a.variables, _b = _a.cache, cache = _b === void 0 ? true : _b, key = _a.key;
        return getOrSet(fetchOptionsOverride, { query: query, variables: variables }, cache, key);
    };
    return exports.client;
}
exports.getClient = getClient;
//# sourceMappingURL=svqlConfig.js.map